<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree | Mouse Drag Edition</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Great+Vibes&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --gold: #ffd700;
            --cream: #fffdd0;
            --heart-color: #ff3366;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Cinzel', serif;
            color: var(--cream);
            user-select: none;
            cursor: none; /* Ẩn chuột mặc định để dùng tim */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        h1 {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 30px;
            letter-spacing: 5px;
            margin: 0;
            font-weight: 400;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            z-index: 10;
            opacity: 0.8;
        }

        /* --- HEART CURSOR --- */
        #heart-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            mix-blend-mode: screen;
            transition: transform 0.1s;
        }

        .heart-shape {
            position: relative;
            width: 20px;
            height: 20px;
            background-color: var(--heart-color);
            transform: rotate(-45deg);
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px var(--heart-color), 0 0 20px var(--heart-color);
        }

        .heart-shape::before,
        .heart-shape::after {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: var(--heart-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--heart-color);
        }

        .heart-shape::before { top: -10px; left: 0; }
        .heart-shape::after { left: 10px; top: 0; }

        @keyframes pulse {
            0% { transform: rotate(-45deg) scale(1); }
            50% { transform: rotate(-45deg) scale(1.2); }
            100% { transform: rotate(-45deg) scale(1); }
        }
        
        /* Hiệu ứng khi click */
        .cursor-click {
            transform: translate(-50%, -50%) scale(0.8) !important;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui-layer">
        <h1>MERRY CHRISTMAS</h1>
    </div>

    <div id="heart-cursor">
        <div class="heart-shape"></div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CẤU HÌNH ---
        const CONFIG = {
            colors: {
                gold: 0xffd700,
                warmWhite: 0xfff4e0,
                red: 0x8a0f0f,
            },
            treeHeight: 30, // Tăng chiều cao để không bị ngắn
            treeMaxRadius: 12,
            particleCount: 5000, 
            snowCount: 1500
        };

        const STATE = {
            mode: 'TREE', // TREE, TEXT, FOCUS
            savedMode: 'TREE',
            focusTarget: null,
            time: 0,
            cursorPos: new THREE.Vector2(),
            // Logic xoay mới
            isDragging: false,
            previousMousePosition: { x: 0, y: 0 },
            rotationVelocity: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 }
        };

        const particles = [];
        const photos = [];
        const mainGroup = new THREE.Group();
        const snowParticles = [];

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); 
        scene.add(mainGroup);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        // Đặt camera xa hơn một chút để thấy toàn bộ cây
        camera.position.set(0, 5, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 0.6; 
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.8;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);
        const innerLight = new THREE.PointLight(0xffaa00, 5, 40);
        innerLight.position.set(0, 5, 0);
        scene.add(innerLight);

        // --- ASSETS ---
        const geoSphere = new THREE.SphereGeometry(1, 12, 12); 
        const geoDiamond = new THREE.OctahedronGeometry(1, 1);
        const geoHitPlane = new THREE.PlaneGeometry(6.0, 6.0);
        
        function createStarGeometry() {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 1.5; const innerRadius = 0.7;
            const angleStep = Math.PI / points;
            for(let i = 0; i < points * 2; i++) {
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const a = i * angleStep;
                const x = Math.cos(a - Math.PI/2) * r;
                const y = Math.sin(a - Math.PI/2) * r;
                if(i===0) shape.moveTo(x, y); else shape.lineTo(x, y);
            }
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3 });
            geometry.center();
            return geometry;
        }
        const geoStar = createStarGeometry();
        
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.1, metalness: 0.9, emissive: 0xaa6600, emissiveIntensity: 0.2 });
        const matRed = new THREE.MeshPhysicalMaterial({ color: 0x880000, metalness: 0.5, roughness: 0.1, clearcoat: 1.0 });
        const matLightWarm = new THREE.MeshStandardMaterial({ color: 0xffffee, emissive: 0xffddaa, emissiveIntensity: 2.0, toneMapped: false });
        const matStar = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 4.0, roughness: 0.4, toneMapped: false });
        const matPhotoFrame = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.9 });
        const geoFrame = new THREE.BoxGeometry(1.6, 1.1, 0.05);
        const geoPhotoPlane = new THREE.PlaneGeometry(1.4, 0.9);
        const matHitBox = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false, side: THREE.DoubleSide });

        // --- TEXT POSITIONS ---
        function generateTextPositions() {
            const positions = [];
            const canvas = document.createElement('canvas');
            const cw = 2048; const ch = 1024; 
            canvas.width = cw; canvas.height = ch;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, cw, ch);
            ctx.fillStyle = '#ffffff';
            ctx.font = '900 130px "Cinzel", serif'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            ctx.fillText("merry christmas", cw / 2, ch * 0.25);
            ctx.fillText("happy happy3>", cw / 2, ch * 0.5);
            ctx.fillText("TTOI YEU CỤA ANH", cw / 2, ch * 0.75);

            const data = ctx.getImageData(0, 0, cw, ch).data;
            const step = 4;
            for (let y = 0; y < ch; y += step) {
                for (let x = 0; x < cw; x += step) {
                    if (data[(y * cw + x) * 4] > 100) {
                        positions.push(new THREE.Vector3((x / cw - 0.5) * 35, -(y / ch - 0.5) * 24 + 2, 0));
                    }
                }
            }
            return positions;
        }
        const textPositions = generateTextPositions();

        // --- PARTICLE CREATION ---
        function createParticle(type, customTex = null) {
            let mesh;
            if (type === 'STAR') {
                mesh = new THREE.Mesh(geoStar, matStar);
                mesh.scale.setScalar(1.2); 
            } else if (type === 'PHOTO') {
                const group = new THREE.Group();
                const tex = customTex || createDefaultPhoto();
                const matPhoto = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide, roughness: 0.6, metalness: 0.1 });
                const photoMesh = new THREE.Mesh(geoPhotoPlane, matPhoto);
                photoMesh.position.z = 0.03;
                const frameMesh = new THREE.Mesh(geoFrame, matPhotoFrame);
                const hitMesh = new THREE.Mesh(geoHitPlane, matHitBox);
                hitMesh.position.z = 0.05; hitMesh.userData.isHitBox = true;

                group.add(frameMesh); group.add(photoMesh); group.add(hitMesh); 
                mesh = group; mesh.userData.isPhoto = true;
                photos.push(mesh);
            } else if (type === 'LIGHT') {
                mesh = new THREE.Mesh(geoSphere, matLightWarm);
                mesh.scale.setScalar(0.08 + Math.random() * 0.05); 
            } else if (type === 'ORNAMENT_GOLD') {
                mesh = new THREE.Mesh(geoDiamond, matGold);
                mesh.scale.setScalar(0.25);
            } else {
                mesh = new THREE.Mesh(geoSphere, matRed);
                mesh.scale.setScalar(0.2);
            }

            const i = particles.length;
            const t = i / CONFIG.particleCount; 
            const angle = t * 65 * Math.PI; // Giảm vòng xoắn để cây trông đầy đặn hơn
            const y = (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
            const radius = CONFIG.treeMaxRadius * (1 - t); 
            
            let treePos = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
            if (type !== 'STAR') { treePos.x += (Math.random() - 0.5) * 1.5; treePos.z += (Math.random() - 0.5) * 1.5; }
            else { treePos.set(0, CONFIG.treeHeight/2 + 0.5, 0); }

            let treeRot = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            if (type === 'PHOTO') {
                const pT = Math.random() * 0.7; const pY = (pT * CONFIG.treeHeight) - (CONFIG.treeHeight/2);
                const pRad = CONFIG.treeMaxRadius * (1 - pT) + 1.0; const pAngle = Math.random() * Math.PI * 2;
                treePos.set(Math.cos(pAngle) * pRad, pY, Math.sin(pAngle) * pRad);
                treeRot.set(0, -pAngle + Math.PI / 2, (Math.random() - 0.5) * 0.2);
            }

            const textIdx = Math.floor((i / CONFIG.particleCount) * textPositions.length);
            const safeTextIdx = textPositions.length > 0 ? (textIdx % textPositions.length) : 0;
            const textPos = textPositions.length > 0 ? textPositions[safeTextIdx].clone() : new THREE.Vector3(0, 0, 0);
            textPos.x += (Math.random() - 0.5) * 0.05; textPos.y += (Math.random() - 0.5) * 0.05;

            mesh.position.copy(treePos);
            mesh.rotation.copy(treeRot);
            
            mesh.userData = {
                type: type,
                treePos: treePos, treeRot: treeRot, textPos: textPos,
                baseScale: mesh.scale.clone(),
                blinkOffset: Math.random() * Math.PI * 2
            };
            mainGroup.add(mesh);
            particles.push(mesh);
        }

        function createDefaultPhoto() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 340;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fceea7'; ctx.fillRect(0, 0, 512, 340);
            ctx.fillStyle = '#d4af37'; ctx.font = 'bold 60px Cinzel';
            ctx.textAlign = 'center'; ctx.fillText('JOYEUX', 256, 140); ctx.fillText('NOEL', 256, 220);
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const textureLoader = new THREE.TextureLoader();
        createParticle('STAR');
        for (let i = 1; i <= 20; i++) {
            textureLoader.load(`./images/${i}.png`, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; createParticle('PHOTO', tex); }, undefined, () => {});
        }
        for (let i = 0; i < CONFIG.particleCount - particles.length; i++) {
            const r = Math.random();
            if (r < 0.6) createParticle('LIGHT'); else if (r < 0.9) createParticle('ORNAMENT_GOLD'); else createParticle('ORNAMENT_RED'); 
        }

        // --- SNOW ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = []; const snowVels = [];
        for(let i=0; i<CONFIG.snowCount; i++) {
            snowPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*80+20, (Math.random()-0.5)*100);
            snowVels.push((Math.random()*0.1)+0.02); 
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- MOUSE & LOGIC ---
        const raycaster = new THREE.Raycaster();
        let clickTimer = null; // Timer để phân biệt click đơn và click đôi

        // 1. Logic chuột (Drag to Rotate)
        document.addEventListener('mousemove', (e) => {
            const cursor = document.getElementById('heart-cursor');
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';

            STATE.cursorPos.x = (e.clientX / window.innerWidth) * 2 - 1;
            STATE.cursorPos.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (STATE.isDragging) {
                const deltaMove = {
                    x: e.clientX - STATE.previousMousePosition.x,
                    y: e.clientY - STATE.previousMousePosition.y
                };
                
                // Xoay cây
                if(STATE.mode !== 'TEXT') {
                    mainGroup.rotation.y += deltaMove.x * 0.005;
                    mainGroup.rotation.x += deltaMove.y * 0.005;
                }

                STATE.previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        document.addEventListener('mousedown', (e) => {
            STATE.isDragging = true;
            STATE.previousMousePosition = { x: e.clientX, y: e.clientY };
            document.getElementById('heart-cursor').classList.add('cursor-click');
        });

        document.addEventListener('mouseup', () => {
            STATE.isDragging = false;
            document.getElementById('heart-cursor').classList.remove('cursor-click');
        });

        // 2. Logic Click (1 lần vs 2 lần)
        document.addEventListener('click', (e) => {
            // Logic chờ để xem có click lần 2 không
            if (clickTimer) {
                clearTimeout(clickTimer);
                clickTimer = null;
                onDoubleClick(); // Nếu bấm nhanh lần 2 -> Gọi Double Click
            } else {
                clickTimer = setTimeout(() => {
                    onSingleClick(); // Nếu hết giờ mà ko bấm -> Gọi Single Click
                    clickTimer = null;
                }, 250); // Thời gian chờ 250ms
            }
        });

        function onSingleClick() {
            // 1 CLICK: Chuyển đổi giữa Cây và Chữ
            if (STATE.mode === 'FOCUS') return; // Đang xem ảnh thì 1 click không làm gì (hoặc có thể thoát)

            if (STATE.mode === 'TREE') {
                STATE.savedMode = STATE.mode;
                STATE.mode = 'TEXT';
            } else {
                STATE.mode = 'TREE'; // Quay về cây
            }
        }

        function onDoubleClick() {
            // 2 CLICK: Xử lý Ảnh
            if (STATE.mode === 'FOCUS') {
                // Đang xem ảnh -> Thoát ra
                STATE.mode = STATE.savedMode || 'TREE';
                return;
            }

            // Raycast kiểm tra xem có bấm trúng ảnh không
            raycaster.setFromCamera(STATE.cursorPos, camera);
            const hitTestObjects = [];
            photos.forEach(g => {
                const hitBox = g.children.find(c => c.userData.isHitBox);
                if (hitBox) hitTestObjects.push(hitBox);
            });
            const intersects = raycaster.intersectObjects(hitTestObjects);
            
            if (intersects.length > 0) {
                // Bấm trúng ảnh -> Phóng to (Focus)
                STATE.focusTarget = intersects[0].object.parent;
                STATE.savedMode = STATE.mode;
                STATE.mode = 'FOCUS';
            } else {
                // Bấm ra ngoài -> Không làm gì (hoặc có thể cho bung lụa nếu muốn)
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            STATE.time += 0.01;

            // Xoay tự động nhẹ nếu không kéo chuột
            if (!STATE.isDragging && (STATE.mode === 'TREE')) {
                 mainGroup.rotation.y += 0.002;
            }
            // Nếu là chữ thì xoay về mặt chính diện
            if (STATE.mode === 'TEXT') {
                 mainGroup.rotation.y += (0 - mainGroup.rotation.y) * 0.05;
                 mainGroup.rotation.x += (0 - mainGroup.rotation.x) * 0.05;
            }

            mainGroup.updateMatrixWorld();
            const focusTarget = STATE.focusTarget;

            particles.forEach((p) => {
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Euler(0,0,0);
                let targetScale = p.userData.baseScale.clone();

                if (p.userData.type === 'LIGHT') {
                     const blink = Math.sin(STATE.time * 2.0 + p.userData.blinkOffset) * 0.5 + 0.5;
                     p.material.emissiveIntensity = 1.0 + blink * 2.0;
                }

                if (STATE.mode === 'FOCUS' && p === focusTarget) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const worldTargetPos = new THREE.Vector3().copy(camera.position).add(camDir.multiplyScalar(15));
                    targetPos.copy(worldTargetPos);
                    mainGroup.worldToLocal(targetPos);
                    targetRot.set(-mainGroup.rotation.x, -mainGroup.rotation.y, -mainGroup.rotation.z);
                    targetScale.setScalar(4.5);
                } else {
                    if (STATE.mode === 'TREE' || (STATE.mode === 'FOCUS' && p !== focusTarget)) {
                         targetPos.copy(p.userData.treePos);
                         targetRot.copy(p.userData.treeRot); 
                    } else if (STATE.mode === 'TEXT') {
                        targetPos.copy(p.userData.textPos);
                        targetRot.set(0, 0, 0); 
                        targetScale.multiplyScalar(0.4);
                    }
                }

                p.position.lerp(targetPos, 0.08);
                p.scale.lerp(targetScale, 0.08);

                if (STATE.mode !== 'FOCUS') {
                    p.rotation.x += (targetRot.x - p.rotation.x) * 0.1;
                    p.rotation.y += (targetRot.y - p.rotation.y) * 0.1;
                    p.rotation.z += (targetRot.z - p.rotation.z) * 0.1;
                }
            });
            
            // Snow
            const snowPositions = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.snowCount; i++) {
                snowPositions[i*3 + 1] -= snowVels[i];
                if (snowPositions[i*3 + 1] < -20) snowPositions[i*3 + 1] = 60;
                snowPositions[i*3] += Math.sin(STATE.time + i) * 0.01;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            composer.render();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
